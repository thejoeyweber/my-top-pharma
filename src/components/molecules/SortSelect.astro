---
/**
 * SortSelect Component
 * 
 * A dropdown component for selecting sort options.
 * Includes both the field to sort by and the direction.
 * 
 * @example
 * ```astro
 * <SortSelect
 *   options={[
 *     { value: 'name_asc', label: 'Name (A-Z)' },
 *     { value: 'name_desc', label: 'Name (Z-A)' },
 *     { value: 'date_desc', label: 'Newest first' }
 *   ]}
 *   selectedValue="name_asc"
 * />
 * ```
 */

export interface SortOption {
  /**
   * Unique value for the option, typically in format 'field_direction'
   */
  value: string;
  
  /**
   * Display label for the option
   */
  label: string;
  
  /**
   * Whether this option is disabled
   * @default false
   */
  disabled?: boolean;
}

export interface SortSelectProps {
  /**
   * Array of sort options to display
   */
  options: SortOption[];
  
  /**
   * Label text to display before the select
   * @default "Sort by"
   */
  label?: string;
  
  /**
   * HTML name attribute for the select element
   * @default "sort"
   */
  name?: string;
  
  /**
   * HTML id attribute for the select element
   * @default "sort-select"
   */
  id?: string;
  
  /**
   * Currently selected option value
   * @default ""
   */
  selectedValue?: string;
  
  /**
   * Additional CSS classes to apply to the container
   */
  class?: string;
  
  /**
   * Whether to auto-submit the parent form on change
   * @default false
   */
  autoSubmit?: boolean;
  
  /**
   * Callback function name to call on change (will be available on window)
   */
  onChange?: string;
}

// Type alias for Props
type Props = SortSelectProps;

const {
  options,
  label = "Sort by",
  name = "sort",
  id = "sort-select",
  selectedValue = "",
  class: className = "",
  autoSubmit = false,
  onChange
} = Astro.props;
---

<div class:list={["sort-select flex flex-col md:flex-row md:items-center gap-2", className]}>
  {label && <label for={id} class="text-sm font-medium text-gray-700 whitespace-nowrap">{label}:</label>}
  
  <div class="relative">
    <select
      id={id}
      name={name}
      class="block w-full rounded-md border border-gray-300 bg-white py-1.5 pl-3 pr-10 text-sm text-gray-900 focus:border-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500"
      data-sort-select
      data-auto-submit={autoSubmit.toString()}
      data-on-change={onChange}
      aria-label={label}
    >
      {options.map(option => (
        <option 
          value={option.value} 
          selected={option.value === selectedValue}
          disabled={option.disabled}
        >
          {option.label}
        </option>
      ))}
    </select>
    
    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
      </svg>
    </div>
  </div>
</div>

<script>
  function initializeSortSelects() {
    const sortSelects = document.querySelectorAll('[data-sort-select]');
    
    sortSelects.forEach(select => {
      // Remove existing event listener if re-initializing
      const oldSelect = select.cloneNode(true);
      select.parentNode?.replaceChild(oldSelect, select);
      select = oldSelect;
      
      select.addEventListener('change', (e) => {
        const selectEl = e.currentTarget as HTMLSelectElement;
        const value = selectEl.value;
        const autoSubmit = selectEl.dataset.autoSubmit === 'true';
        const onChangeFn = selectEl.dataset.onChange;
        
        // Dispatch a custom event that can be listened for to update sorting
        const event = new CustomEvent('sort:changed', { 
          detail: { value },
          bubbles: true 
        });
        selectEl.dispatchEvent(event);
        
        // Auto-submit parent form if enabled
        if (autoSubmit) {
          const form = selectEl.closest('form');
          if (form) {
            form.submit();
          }
        }
        
        // Call onChange function if provided
        if (onChangeFn && typeof window[onChangeFn] === 'function') {
          window[onChangeFn](value, selectEl);
        }
      });
    });
  }
  
  // Initialize on page load
  document.addEventListener('DOMContentLoaded', initializeSortSelects);
  
  // Re-initialize after Astro page transitions
  document.addEventListener('astro:page-load', initializeSortSelects);
</script> 